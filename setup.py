#!/usr/bin/env python3
"""
Setup script for CCS dependencies
"""
import argparse
import os
import sys
import yaml
import logging
import json
import importlib.util
from pathlib import Path
from utils.environment import Environment
from utils.system import detect_system


def main():
    """
    Main function for setting up the CCS dependencies environment.
    
    This can be run directly or as a Poetry entry point with: ccs-setup
    """
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Set up environment for CCS dependencies")
    parser.add_argument("--env", default=None, help="Environment name (e.g., gnu_ubuntu, gnu_macos)")
    parser.add_argument("--config", default=None, help="Path to custom configuration file")
    parser.add_argument("--install-dir", default=None, help="Installation directory")
    parser.add_argument("--build-dir", default=None, help="Build directory")
    parser.add_argument("--format", choices=["bash", "json", "python"], default="bash", 
                        help="Output format (bash, json, or python)")
    parser.add_argument("--version", action="store_true", help="Show version information")
    args = parser.parse_args()
    
    # Show version info if requested
    if args.version:
        show_version_info()
        return
    
    # Check for Poetry environment
    check_poetry_environment()
    
    # Detect system if environment not specified
    env_name = args.env
    if not env_name:
        env_name = detect_system()
    
    # Load configuration
    config = load_configuration(env_name, args.config)
    
    # Override with command line arguments
    if args.install_dir:
        config["install_dir"] = args.install_dir
    if args.build_dir:
        config["build_dir"] = args.build_dir
    
    # Set up environment
    env = Environment(env_name, config)
    env_vars = env.get_env_vars()
    
    # Output environment variables in the requested format
    if args.format == "json":
        print(json.dumps(env_vars, indent=2))
    elif args.format == "python":
        print("# Python environment variables")
        print("env_vars = {")
        for key, value in env_vars.items():
            print(f'    "{key}": "{value}",')
        print("}")
    else:  # bash
        print("#!/bin/bash")
        print("# This file was generated by setup.py")
        print(f"# Environment: {env_name}")
        print()
        
        for key, value in env_vars.items():
            # Handle special characters in the value
            value_escaped = value.replace('"', '\\"')
            print(f'export {key}="{value_escaped}"')


def show_version_info():
    """
    Display version information for the CCS dependencies setup
    """
    # Try to get version from pyproject.toml using Poetry metadata
    try:
        from importlib.metadata import version
        print(f"CCS Dependencies Setup v{version('ccs-dependencies')}")
    except (ImportError, ModuleNotFoundError):
        # Fallback if not installed with Poetry
        print("CCS Dependencies Setup")
    
    print("Python version:", sys.version)
    print("Platform:", sys.platform)


def check_poetry_environment():
    """
    Check if running in a Poetry environment and verify dependencies are available
    """
    # Verify required packages are available
    required_packages = ["yaml"]
    
    for package in required_packages:
        if importlib.util.find_spec(package) is None:
            print(f"Warning: Required package '{package}' not found.", file=sys.stderr)
            print("Consider using Poetry to manage dependencies:", file=sys.stderr)
            print("  poetry install", file=sys.stderr)
            print("  poetry run ccs-setup", file=sys.stderr)


def load_configuration(env_name, custom_config=None):
    """
    Load configuration for the specified environment
    
    Args:
        env_name (str): Environment name
        custom_config (str, optional): Path to custom configuration file
        
    Returns:
        dict: Configuration dictionary
    """
    # Current script directory - handle both direct execution and installed package
    try:
        # If running as an installed package
        import ccs_dependencies
        package_dir = Path(ccs_dependencies.__file__).parent
        config_dir = package_dir / "config"
    except ImportError:
        # If running directly from source
        script_dir = Path(__file__).parent
        config_dir = script_dir / "config"
    
    # Load default configuration
    default_config_path = config_dir / "default_config.yml"
    if not default_config_path.exists():
        print(f"Error: Default configuration file not found: {default_config_path}", file=sys.stderr)
        sys.exit(1)
    
    with open(default_config_path, "r") as f:
        config = yaml.safe_load(f)
    
    # Load environment-specific configuration
    env_config_path = config_dir / f"{env_name}.yml"
    if env_config_path.exists():
        with open(env_config_path, "r") as f:
            env_config = yaml.safe_load(f)
            # Merge configurations
            config = merge_configs(config, env_config)
    
    # Load custom configuration if specified
    if custom_config and os.path.exists(custom_config):
        with open(custom_config, "r") as f:
            custom_config_data = yaml.safe_load(f)
            # Merge configurations
            config = merge_configs(config, custom_config_data)
    
    return config


def merge_configs(base_config, override_config):
    """
    Recursively merge two configuration dictionaries
    
    Args:
        base_config (dict): Base configuration
        override_config (dict): Override configuration
        
    Returns:
        dict: Merged configuration
    """
    result = base_config.copy()
    for key, value in override_config.items():
        if (
            key in result and 
            isinstance(result[key], dict) and 
            isinstance(value, dict)
        ):
            result[key] = merge_configs(result[key], value)
        else:
            result[key] = value
    return result


if __name__ == "__main__":
    main()