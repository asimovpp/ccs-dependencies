#!/usr/bin/env python3
"""
Setup script for CCS dependencies
"""
import argparse
import os
import sys
import yaml
import logging
import json
import importlib.util
from pathlib import Path
from ccs_dep.utils.environment import Environment
from ccs_dep.utils.system import detect_system


def main():
    """
    Main function for setting up the CCS dependencies environment.
    
    This can be run directly or as a Poetry entry point with: ccs-setup
    """
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Set up environment for CCS dependencies")
    parser.add_argument("--env", default=None, help="Environment name (e.g., gnu_ubuntu, gnu_macos)")
    parser.add_argument("--config", default=None, help="Path to custom configuration file")
    parser.add_argument("--install-dir", default=None, help="Installation directory")
    parser.add_argument("--build-dir", default=None, help="Build directory")
    parser.add_argument("--format", choices=["bash", "fish", "json", "python"], default="bash", 
                        help="Output format (bash, fish, json, or python)")
    parser.add_argument("--version", action="store_true", help="Show version information")
    args = parser.parse_args()
    
    # Show version info if requested
    if args.version:
        show_version_info()
        return
    
    # Check for Poetry environment
    check_poetry_environment()
    
    # Detect system if environment not specified
    env_name = args.env
    if not env_name:
        env_name = detect_system()
    
    # Load configuration
    config = load_configuration(env_name, args.config)
    
    # Override with command line arguments
    if args.install_dir:
        config["install_dir"] = str(Path(args.install_dir).expanduser())
    if args.build_dir:
        config["build_dir"] = str(Path(args.build_dir).expanduser())
    
    # Set up environment
    env = Environment(env_name, config)
    env_vars = env.get_env_vars()
    
    # Output environment variables in the requested format
    if args.format == "json":
        print(json.dumps(env_vars, indent=2))
    elif args.format == "python":
        print("# Python environment variables")
        print("env_vars = {")
        for key, value in env_vars.items():
            print(f'    "{key}": "{value}",')
        print("}")
    elif args.format == "fish":
        print("#!/usr/bin/env fish")
        print("# This file was generated by setup.py")
        print(f"# Environment: {env_name}")
        print()
        
        for key, value in env_vars.items():
            # Special handling for PATH-like variables that should be space-separated lists in Fish
            if key in ["PATH", "PYTHONPATH", "LD_LIBRARY_PATH"] and ":" in str(value):
                # Split by colon and create a Fish array with proper quoting
                paths = str(value).split(":")
                if paths[-1] == "":  # Remove trailing empty path if present
                    paths = paths[:-1]
                    
                # Fish arrays are space-separated quoted items
                quoted_paths = []
                for path in paths:
                    if path:  # Skip empty paths
                        # Escape any single quotes
                        path_escaped = path.replace("'", "\\'")
                        quoted_paths.append(f"'{path_escaped}'")
                
                if quoted_paths:
                    print(f"set -gx {key} {' '.join(quoted_paths)}")
                else:
                    print(f"set -gx {key} ''")
            else:
                # Regular variables just need quotes and escaping
                value_escaped = str(value).replace("'", "\\'")
                print(f"set -gx {key} '{value_escaped}'")
        
        # Add Python virtual environment activation for Fish
        script_dir = Path(__file__).parent
        base_dir = script_dir.parent  # ccs-dependencies root
        venv_path = base_dir / ".venv"
        
        if venv_path.exists():
            fish_activate = venv_path / "bin" / "activate.fish"
            if fish_activate.exists():
                print("\n# Activate Python virtual environment")
                print(f"source '{fish_activate}'")
                print("echo 'Python virtual environment activated'")
    else:  # bash
        print("#!/bin/bash")
        print("# This file was generated by setup.py")
        print(f"# Environment: {env_name}")
        print()
        
        for key, value in env_vars.items():
            # Handle special characters in the value
            value_escaped = str(value).replace('"', '\\"')
            print(f'export {key}="{value_escaped}"')
        
        # Add Python virtual environment activation for Bash
        script_dir = Path(__file__).parent
        base_dir = script_dir.parent  # ccs-dependencies root
        venv_path = base_dir / ".venv"
        
        if venv_path.exists():
            bash_activate = venv_path / "bin" / "activate"
            if bash_activate.exists():
                print("\n# Activate Python virtual environment")
                print(f"source \"{bash_activate}\"")
                print("echo 'Python virtual environment activated'")


def show_version_info():
    """
    Display version information for the CCS dependencies setup
    """
    # Try to get version from package
    try:
        from ccs_dep import __version__
        print(f"CCS Dependencies Setup v{__version__}")
    except (ImportError, ModuleNotFoundError):
        # Fallback if not installed with Poetry
        print("CCS Dependencies Setup v0.1.0")
    
    print("Python version:", sys.version)
    print("Platform:", sys.platform)


def check_poetry_environment():
    """
    Check if running in a Poetry environment and verify dependencies are available
    """
    # Verify required packages are available
    required_packages = ["yaml"]
    
    for package in required_packages:
        if importlib.util.find_spec(package) is None:
            print(f"Warning: Required package '{package}' not found.", file=sys.stderr)
            print("Consider using Poetry to manage dependencies:", file=sys.stderr)
            print("  poetry install", file=sys.stderr)
            print("  poetry run ccs-setup", file=sys.stderr)


def load_configuration(env_name, custom_config=None):
    """
    Load configuration for the specified environment
    
    Args:
        env_name (str): Environment name
        custom_config (str, optional): Path to custom configuration file
        
    Returns:
        dict: Configuration dictionary
    """
    # Get the configuration directory - first check the repo root (the original location)
    script_dir = Path(__file__).parent
    base_dir = script_dir.parent  # This would be ccs-dependencies root
    config_dir = base_dir / "config"
    
    # Check if config directory exists
    if not config_dir.exists():
        print(f"Error: Configuration directory not found: {config_dir}", file=sys.stderr)
        sys.exit(1)
    
    # Load default configuration
    default_config_path = config_dir / "default_config.yml"
    if not default_config_path.exists():
        print(f"Error: Default configuration file not found: {default_config_path}", file=sys.stderr)
        sys.exit(1)
    
    with open(default_config_path, "r") as f:
        config = yaml.safe_load(f)
    
    # Load environment-specific configuration
    env_config_path = config_dir / f"{env_name}.yml"
    if env_config_path.exists():
        with open(env_config_path, "r") as f:
            env_config = yaml.safe_load(f)
            # Merge configurations
            config = merge_configs(config, env_config)
    
    # Load custom configuration if specified
    if custom_config:
        custom_config_path = Path(custom_config)
        if custom_config_path.exists():
            with custom_config_path.open("r") as f:
                custom_config_data = yaml.safe_load(f)
                # Merge configurations
                config = merge_configs(config, custom_config_data)
    
    return config


def merge_configs(base_config, override_config):
    """
    Recursively merge two configuration dictionaries
    
    Args:
        base_config (dict): Base configuration
        override_config (dict): Override configuration
        
    Returns:
        dict: Merged configuration
    """
    result = base_config.copy()
    for key, value in override_config.items():
        if (
            key in result and 
            isinstance(result[key], dict) and 
            isinstance(value, dict)
        ):
            result[key] = merge_configs(result[key], value)
        else:
            result[key] = value
    return result


if __name__ == "__main__":
    main()